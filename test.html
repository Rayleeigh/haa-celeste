<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SES Super Destroyer - Hologram</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; /* Deep black for hologram contrast */
            background-image: linear-gradient(rgba(253, 216, 8, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(253, 216, 8, 0.05) 1px, transparent 1px);
            background-size: 30px 30px; /* Subtle background grid */
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #FDD808;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 1.2rem;
            pointer-events: none;
            text-shadow: 0 0 10px #FDD808;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="info">Super Earth Network<br/>Transmission Intercepted</div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene & Camera Setup ---
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(18, 12, -25);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 2. Holographic Materials (#FDD808) ---
        const holoColor = 0xFDD808;
        
        // Faint, transparent solid fill
        const matSolid = new THREE.MeshBasicMaterial({ 
            color: holoColor, 
            transparent: true, 
            opacity: 0.15,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // Bright wireframe outline
        const matWire = new THREE.MeshBasicMaterial({ 
            color: holoColor, 
            wireframe: true,
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        // --- 3. Ship Construction ---
        const ship = new THREE.Group();

        // Utility function to layer wireframe over solid geometry
        function addPart(geometry, x, y, z, rotX=0, rotY=0, rotZ=0) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            group.rotation.set(rotX, rotY, rotZ);
            
            const meshSolid = new THREE.Mesh(geometry, matSolid);
            const meshWire = new THREE.Mesh(geometry, matWire);
            
            group.add(meshSolid);
            group.add(meshWire);
            ship.add(group);
        }

        // --- REAR: Engine Block & Bracket Armor ---
        addPart(new THREE.BoxGeometry(3.8, 3.2, 5), 0, 0, 8.5);
        addPart(new THREE.CylinderGeometry(2.8, 2.8, 1, 4), 0, 0, 11, Math.PI/2, Math.PI/4, 0);
        addPart(new THREE.CylinderGeometry(2.2, 2.2, 5.5, 4), 2.8, 0, 8.2, Math.PI/2, Math.PI/4, 0);
        addPart(new THREE.CylinderGeometry(2.2, 2.2, 5.5, 4), -2.8, 0, 8.2, Math.PI/2, Math.PI/4, 0);

        // 10-Engine Cluster
        const engineGeoLg = new THREE.CylinderGeometry(0.5, 0.4, 0.8, 8);
        const engineGeoSm = new THREE.CylinderGeometry(0.3, 0.2, 0.6, 8);
        addPart(engineGeoLg, 2.5, 1, 11.2, Math.PI/2, 0, 0);
        addPart(engineGeoLg, 2.5, -1, 11.2, Math.PI/2, 0, 0);
        addPart(engineGeoLg, -2.5, 1, 11.2, Math.PI/2, 0, 0);
        addPart(engineGeoLg, -2.5, -1, 11.2, Math.PI/2, 0, 0);
        
        const innerPositions = [ [1,0.8], [-1,0.8], [1.2,-0.5], [-1.2,-0.5], [0,-1], [0,0] ];
        innerPositions.forEach(pos => {
            addPart(engineGeoSm, pos[0], pos[1], 11.4, Math.PI/2, 0, 0);
        });

        // --- MIDSECTION: Hull & Hangar ---
        addPart(new THREE.BoxGeometry(3.2, 2.8, 8), 0, 0, 2);
        addPart(new THREE.CylinderGeometry(2, 2, 6, 4), 0, -1.2, 2.5, Math.PI/2, Math.PI/4, 0);
        
        // --- COMMAND BRIDGE ---
        addPart(new THREE.BoxGeometry(2.2, 1.2, 3), 0, 1.8, 3.5);
        addPart(new THREE.CylinderGeometry(1, 1, 2.2, 3), 0, 2, 1.7, 0, 0, Math.PI/2);

        // --- FRONT: Rails & Antenna Array ---
        addPart(new THREE.BoxGeometry(1.4, 1.4, 11), 0, 0, -7.5);
        addPart(new THREE.BoxGeometry(0.6, 1, 14), 1.5, 0, -9);
        addPart(new THREE.BoxGeometry(0.6, 1, 14), -1.5, 0, -9);

        // Struts
        for(let z = -3; z > -12; z -= 2) {
            addPart(new THREE.CylinderGeometry(0.1, 0.1, 3, 4), 0, 0, z, 0, 0, Math.PI/2);
        }

        // Antenna
        addPart(new THREE.CylinderGeometry(0.1, 0.1, 4, 4), 0, 0.2, -15, Math.PI/2, 0, 0);
        addPart(new THREE.CylinderGeometry(0.05, 0.05, 2, 4), 0.3, -0.2, -14, Math.PI/2, 0, 0);
        addPart(new THREE.CylinderGeometry(0.05, 0.05, 2, 4), -0.3, -0.2, -14, Math.PI/2, 0, 0);

        // --- ORBITAL WEAPONS ---
        const cannonBase = new THREE.BoxGeometry(1, 0.8, 2);
        const barrel = new THREE.CylinderGeometry(0.15, 0.15, 2, 4);
        addPart(cannonBase, 0, -1.8, -1);
        addPart(barrel, 0, -2, -2.5, Math.PI/2, 0, 0);
        addPart(cannonBase, 0, -1.2, -5);
        addPart(barrel, 0, -1.4, -6.5, Math.PI/2, 0, 0);

        scene.add(ship);
        controls.target.set(0, 0, 0);

        // --- 4. Animation & Glitch Logic ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Base rotation speed
        let targetRotation = 0.002;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Standard rotation
            ship.rotation.y += targetRotation;

            // --- Custom Glitch Effect ---
            // 4% chance every frame to trigger a glitch
            if (Math.random() < 0.04) {
                // Random position offset (jitter)
                ship.position.x = (Math.random() - 0.5) * 0.8;
                ship.position.y = (Math.random() - 0.5) * 0.8;
                ship.position.z = (Math.random() - 0.5) * 0.8;
                
                // Opacity flicker
                matWire.opacity = 0.2 + Math.random() * 0.8;
                matSolid.opacity = Math.random() * 0.3;

                // Brief rotation stutter
                ship.rotation.y += (Math.random() - 0.5) * 0.1;

                // Snap back to normal quickly
                setTimeout(() => {
                    ship.position.set(0, 0, 0);
                    matWire.opacity = 0.8;
                    matSolid.opacity = 0.15;
                }, 50 + Math.random() * 100); 
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>